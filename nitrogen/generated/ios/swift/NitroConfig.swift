///
/// NitroConfig.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2024 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `NitroConfig`, backed by a C++ struct.
 */
public typealias NitroConfig = margelo.nitro.multipleimagepicker.NitroConfig

public extension NitroConfig {
  private typealias bridge = margelo.nitro.multipleimagepicker.bridge.swift

  /**
   * Create a new instance of `NitroConfig`.
   */
  init(mediaType: MediaType, selectedAssets: [PickerResult], selectBoxStyle: SelectBoxStyle, selectMode: SelectMode, numberOfColumn: Double?, isPreview: Bool?, primaryColor: Double?, allowSwipeToSelect: Bool?, spacing: Double?, isHiddenPreviewButton: Bool?, isHiddenOriginalButton: Bool?, isShowPreviewList: Bool?, allowHapticTouchPreview: Bool?, allowedLimit: Bool?, maxVideo: Double?, maxSelect: Double?, maxVideoDuration: Double?, minVideoDuration: Double?, maxFileSize: Double?, backgroundDark: Double?, crop: PickerCropConfig?, text: Text?, language: Language, theme: Theme, presentation: Presentation, camera: PickerCameraConfig?) {
    self.init(mediaType, { () -> bridge.std__vector_PickerResult_ in
      var __vector = bridge.create_std__vector_PickerResult_(selectedAssets.count)
      for __item in selectedAssets {
        __vector.push_back(__item)
      }
      return __vector
    }(), selectBoxStyle, selectMode, { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = numberOfColumn {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = isPreview {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = primaryColor {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = allowSwipeToSelect {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = spacing {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = isHiddenPreviewButton {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = isHiddenOriginalButton {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = isShowPreviewList {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = allowHapticTouchPreview {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = allowedLimit {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = maxVideo {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = maxSelect {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = maxVideoDuration {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = minVideoDuration {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = maxFileSize {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = backgroundDark {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_PickerCropConfig_ in
      if let __unwrappedValue = crop {
        return bridge.create_std__optional_PickerCropConfig_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_Text_ in
      if let __unwrappedValue = text {
        return bridge.create_std__optional_Text_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), language, theme, presentation, { () -> bridge.std__optional_PickerCameraConfig_ in
      if let __unwrappedValue = camera {
        return bridge.create_std__optional_PickerCameraConfig_(__unwrappedValue)
      } else {
        return .init()
      }
    }())
  }

  var mediaType: MediaType {
    @inline(__always)
    get {
      return self.__mediaType
    }
    @inline(__always)
    set {
      self.__mediaType = newValue
    }
  }
  
  var selectedAssets: [PickerResult] {
    @inline(__always)
    get {
      return self.__selectedAssets.map({ __item in __item })
    }
    @inline(__always)
    set {
      self.__selectedAssets = { () -> bridge.std__vector_PickerResult_ in
        var __vector = bridge.create_std__vector_PickerResult_(newValue.count)
        for __item in newValue {
          __vector.push_back(__item)
        }
        return __vector
      }()
    }
  }
  
  var selectBoxStyle: SelectBoxStyle {
    @inline(__always)
    get {
      return self.__selectBoxStyle
    }
    @inline(__always)
    set {
      self.__selectBoxStyle = newValue
    }
  }
  
  var selectMode: SelectMode {
    @inline(__always)
    get {
      return self.__selectMode
    }
    @inline(__always)
    set {
      self.__selectMode = newValue
    }
  }
  
  var numberOfColumn: Double? {
    @inline(__always)
    get {
      return self.__numberOfColumn.value
    }
    @inline(__always)
    set {
      self.__numberOfColumn = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var isPreview: Bool? {
    @inline(__always)
    get {
      return self.__isPreview.value
    }
    @inline(__always)
    set {
      self.__isPreview = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var primaryColor: Double? {
    @inline(__always)
    get {
      return self.__primaryColor.value
    }
    @inline(__always)
    set {
      self.__primaryColor = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var allowSwipeToSelect: Bool? {
    @inline(__always)
    get {
      return self.__allowSwipeToSelect.value
    }
    @inline(__always)
    set {
      self.__allowSwipeToSelect = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var spacing: Double? {
    @inline(__always)
    get {
      return self.__spacing.value
    }
    @inline(__always)
    set {
      self.__spacing = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var isHiddenPreviewButton: Bool? {
    @inline(__always)
    get {
      return self.__isHiddenPreviewButton.value
    }
    @inline(__always)
    set {
      self.__isHiddenPreviewButton = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var isHiddenOriginalButton: Bool? {
    @inline(__always)
    get {
      return self.__isHiddenOriginalButton.value
    }
    @inline(__always)
    set {
      self.__isHiddenOriginalButton = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var isShowPreviewList: Bool? {
    @inline(__always)
    get {
      return self.__isShowPreviewList.value
    }
    @inline(__always)
    set {
      self.__isShowPreviewList = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var allowHapticTouchPreview: Bool? {
    @inline(__always)
    get {
      return self.__allowHapticTouchPreview.value
    }
    @inline(__always)
    set {
      self.__allowHapticTouchPreview = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var allowedLimit: Bool? {
    @inline(__always)
    get {
      return self.__allowedLimit.value
    }
    @inline(__always)
    set {
      self.__allowedLimit = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var maxVideo: Double? {
    @inline(__always)
    get {
      return self.__maxVideo.value
    }
    @inline(__always)
    set {
      self.__maxVideo = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var maxSelect: Double? {
    @inline(__always)
    get {
      return self.__maxSelect.value
    }
    @inline(__always)
    set {
      self.__maxSelect = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var maxVideoDuration: Double? {
    @inline(__always)
    get {
      return self.__maxVideoDuration.value
    }
    @inline(__always)
    set {
      self.__maxVideoDuration = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var minVideoDuration: Double? {
    @inline(__always)
    get {
      return self.__minVideoDuration.value
    }
    @inline(__always)
    set {
      self.__minVideoDuration = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var maxFileSize: Double? {
    @inline(__always)
    get {
      return self.__maxFileSize.value
    }
    @inline(__always)
    set {
      self.__maxFileSize = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var backgroundDark: Double? {
    @inline(__always)
    get {
      return self.__backgroundDark.value
    }
    @inline(__always)
    set {
      self.__backgroundDark = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var crop: PickerCropConfig? {
    @inline(__always)
    get {
      return { () -> PickerCropConfig? in
        if let __unwrapped = self.__crop.value {
          return __unwrapped
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__crop = { () -> bridge.std__optional_PickerCropConfig_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_PickerCropConfig_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var text: Text? {
    @inline(__always)
    get {
      return { () -> Text? in
        if let __unwrapped = self.__text.value {
          return __unwrapped
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__text = { () -> bridge.std__optional_Text_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_Text_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var language: Language {
    @inline(__always)
    get {
      return self.__language
    }
    @inline(__always)
    set {
      self.__language = newValue
    }
  }
  
  var theme: Theme {
    @inline(__always)
    get {
      return self.__theme
    }
    @inline(__always)
    set {
      self.__theme = newValue
    }
  }
  
  var presentation: Presentation {
    @inline(__always)
    get {
      return self.__presentation
    }
    @inline(__always)
    set {
      self.__presentation = newValue
    }
  }
  
  var camera: PickerCameraConfig? {
    @inline(__always)
    get {
      return { () -> PickerCameraConfig? in
        if let __unwrapped = self.__camera.value {
          return __unwrapped
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__camera = { () -> bridge.std__optional_PickerCameraConfig_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_PickerCameraConfig_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
}
